#!/usr/bin/env bash
set -euo pipefail

CONFIG="/etc/pihole-group-toggle.conf"
UNIT_BASE="pihole-group-toggle"
SYSTEMD_ETC="/etc/systemd/system"

die() { echo "ERROR: $*" >&2; exit 1; }

require_root() {
  [[ "${EUID}" -eq 0 ]] || die "Run as root (use sudo)."
}

load_config() {
  [[ -f "$CONFIG" ]] || die "Missing config: $CONFIG"
  # shellcheck disable=SC1090
  source "$CONFIG"

  # If SCHEDULES is missing, treat it as empty.
  if ! declare -p SCHEDULES >/dev/null 2>&1; then
    SCHEDULES=()
  fi

  # Enforce that SCHEDULES is an array
  if ! declare -p SCHEDULES 2>/dev/null | grep -q '^declare \-a '; then
    die "SCHEDULES must be a bash array. Use: SCHEDULES=( ...) or SCHEDULES=()"
  fi
}

parse_entry() {
  local entry="$1"
  local group action cal
  
  # Check if entry starts with a quote
  if [[ "$entry" =~ ^\"([^\"]+)\"[[:space:]]+([^[:space:]]+)[[:space:]]+(.+)$ ]]; then
    # Quoted group name: extract group, action, and calendar
    group="${BASH_REMATCH[1]}"
    action="${BASH_REMATCH[2]}"
    cal="${BASH_REMATCH[3]}"
  else
    # Unquoted: use simple word splitting
    read -r group action cal <<<"$entry"
  fi

  [[ -n "${group:-}" ]] || die "Bad entry (missing group): $entry"
  [[ "${action:-}" == "enable" || "${action:-}" == "disable" ]] || die "Bad entry (action must be enable|disable): $entry"
  [[ -n "${cal:-}" ]] || die "Bad entry (missing OnCalendar value): $entry"

  printf '%s\n' "$group" "$action" "$cal"
}

validate_entry() {
  local idx="$1"
  local entry="$2"

  local group action cal
  mapfile -t parts < <(parse_entry "$entry")
  group="${parts[0]:-}"
  action="${parts[1]:-}"
  cal="${parts[2]:-}"

  if [[ -z "$group" || -z "$action" || -z "$cal" ]]; then
    die "Invalid schedule at index $idx: must be \"<group> <enable|disable> <OnCalendar>\""
  fi

  # Action
  case "$action" in
    enable|disable) ;;
    *) die "Invalid action at index $idx: '$action' (must be enable or disable)" ;;
  esac

  # Restrict Group to safe characters
  if [[ ! "$group" =~ ^[A-Za-z0-9._:\ -]+$ ]]; then
    die "Invalid group at index $idx: '$group' (allowed: A-Z a-z 0-9 . _ : -)"
  fi

  # Validate OnCalendar
  if ! systemd-analyze calendar "$cal" >/dev/null 2>&1; then
    die "Invalid OnCalendar at index $idx: '$cal' (try: systemd-analyze calendar \"$cal\")"
  fi

  # Validate the group exists in Pi-hole DB (fast-fail)
  if command -v pihole-FTL >/dev/null 2>&1 && [[ -f /etc/pihole/gravity.db ]]; then
    local db="/etc/pihole/gravity.db"
    local group_sql=${group//\'/\'\'}
    local exists
    exists="$(pihole-FTL sqlite3 "$db" "SELECT COUNT(1) FROM \"group\" WHERE name='$group_sql';" 2>/dev/null || true)"
    if [[ "$exists" != "1" ]]; then
      die "Group not found in Pi-hole DB at index $idx: '$group'"
    fi
  fi
}

validate_config() {
  local i
  for i in "${!SCHEDULES[@]}"; do
    validate_entry "$i" "${SCHEDULES[$i]}"
  done
}

# Encode / Decode for Readable Timer Names with Spaces
encode_group() {
  local group="$1"
  echo "${group// /__}"
}

decode_group() {
  local encoded="$1"
  echo "${encoded//__/ }"
}

timer_unit() {
  local action="$1" group="$2"
  local encoded_group
  encoded_group="$(encode_group "$group")"
  echo "${UNIT_BASE}@${action}:${encoded_group}.timer"
}

dropin_dir() {
  local action="$1" group="$2"
  local encoded_group
  encoded_group="$(encode_group "$group")"
  echo "${SYSTEMD_ETC}/${UNIT_BASE}@${action}:${encoded_group}.timer.d"
}

write_dropin() {
  local action="$1" group="$2" cal="$3"
  local dir file
  dir="$(dropin_dir "$action" "$group")"
  file="${dir}/schedule.conf"

  mkdir -p "$dir"
  cat >"$file" <<EOC
# Managed by pihole-toggle
[Timer]
OnCalendar=
OnCalendar=${cal}
EOC
}

desired_timers() {
  load_config
  local e group action
  for e in "${SCHEDULES[@]}"; do
    mapfile -t parts < <(parse_entry "$e")
    group="${parts[0]}"; action="${parts[1]}"
    timer_unit "$action" "$group"
  done
}

existing_managed_timers() {
  local f rel unit

  while IFS= read -r -d '' f; do
    # Only prune if ownership marker is present
    grep -q '^# Managed by pihole-toggle$' "$f" || continue

    rel="${f#${SYSTEMD_ETC}/}"
    unit="${rel%.d/schedule.conf}"

    [[ "$unit" == ${UNIT_BASE}@*.timer ]] || continue
    printf '%s\n' "$unit"
  done < <(
    find "$SYSTEMD_ETC" -type f \
      -path "${SYSTEMD_ETC}/${UNIT_BASE}@*.timer.d/schedule.conf" \
      -print0 2>/dev/null
  )
}

prune_removed() {
  # Build lookup table of desired timers
  declare -A want=()
  local t
  while IFS= read -r t; do
    want["$t"]=1
  done < <(desired_timers | sort -u)

  # For each existing managed timer, disable/remove if not desired
  local unit action encoded_group group dir
  while IFS= read -r unit; do
    # Safety: only prune timers have managed by ownership marker
    [[ "$unit" == ${UNIT_BASE}@*.timer ]] || continue

    [[ -n "${want[$unit]+x}" ]] && continue

    echo "Removing unmanaged timer: $unit"
    systemctl disable --now "$unit" || true

    # unit is pihole-group-toggle@action:encoded_group.timer
    # derive drop-in dir from action/encoded_group
    action="${unit#${UNIT_BASE}@}"
    action="${action%%:*}"
    encoded_group="${unit#${UNIT_BASE}@${action}:}"
    encoded_group="${encoded_group%.timer}"
    
    # Decode the group name back to original (with spaces)
    group="$(decode_group "$encoded_group")"

    dir="$(dropin_dir "$action" "$group")"
    rm -rf "$dir"
  done < <(existing_managed_timers)
}

cmd_configure() {
  require_root

  local editor="${EDITOR:-}"

  if [[ -z "$editor" ]]; then
    if command -v nano >/dev/null 2>&1; then
      editor=nano
    elif command -v vi >/dev/null 2>&1; then
      editor=vi
    else
      die "No editor found. Set \$EDITOR or install nano or vi."
    fi
  fi

  exec "$editor" "$CONFIG"
}

cmd_validate() {
  load_config
  validate_config
  echo "Config OK."
}

cmd_list() {
  load_config

  if ((${#SCHEDULES[@]} == 0)); then
    echo "No timers defined."
    echo "Add timers by editing $CONFIG (run: pihole-toggle configure)"
    return 0
  fi

  for e in "${SCHEDULES[@]}"; do
    mapfile -t parts < <(parse_entry "$e")
    local group="${parts[0]}" action="${parts[1]}" cal="${parts[2]}"
    echo "group=${group} action=${action} OnCalendar=${cal}"
  done
}

cmd_status() {
  local units=()

  while IFS= read -r u; do
    units+=("$u")
  done < <(existing_managed_timers)

  if ((${#units[@]} == 0)); then
    echo "No managed timers found."
    echo "Add timers by editing $CONFIG (run: pihole-toggle configure)"
    return 0
  fi

  systemctl list-timers --all "${units[@]}"
}

cmd_apply() {
  require_root
  load_config
  validate_config

  # Verify systemd can see the template timer unit
  if ! systemctl cat "${UNIT_BASE}@.timer" >/dev/null 2>&1; then
    die "Cannot find ${UNIT_BASE}@.timer. Install the template timer unit first."
  fi

  for e in "${SCHEDULES[@]}"; do
    mapfile -t parts < <(parse_entry "$e")
    local group="${parts[0]}" action="${parts[1]}" cal="${parts[2]}"
    write_dropin "$action" "$group" "$cal"
    echo "Configured $(timer_unit "$action" "$group")"
  done

  systemctl daemon-reload

  for e in "${SCHEDULES[@]}"; do
    mapfile -t parts < <(parse_entry "$e")
    local group="${parts[0]}" action="${parts[1]}"
    systemctl enable --now "$(timer_unit "$action" "$group")"
  done
}

cmd_prune() {
  require_root
  load_config
  prune_removed
  systemctl daemon-reload
}

cmd_sync() {
  require_root
  load_config

  # If no schedules are defined, interpret sync as: remove all managed timers.
  if ((${#SCHEDULES[@]} == 0)); then
    prune_removed
    systemctl daemon-reload
    return 0
  fi

  cmd_apply
  prune_removed
  systemctl daemon-reload
}

cmd_purge() {
  require_root

  local unit action encoded_group group dir

  # Disable and remove every managed timer (ignores config)
  while IFS= read -r unit; do
    [[ -n "$unit" ]] || continue
    [[ "$unit" == ${UNIT_BASE}@*.timer ]] || continue

    echo "Purging timer: $unit"
    systemctl disable --now "$unit" || true

    # Extract action and encoded group name from unit name
    action="${unit#${UNIT_BASE}@}"
    action="${action%%:*}"
    encoded_group="${unit#${UNIT_BASE}@${action}:}"
    encoded_group="${encoded_group%.timer}"
    
    # Decode the group name back to original (with spaces)
    group="$(decode_group "$encoded_group")"

    dir="$(dropin_dir "$action" "$group")"
    rm -rf "$dir"
  done < <(existing_managed_timers)

  systemctl daemon-reload
}

usage() {
  cat <<EOU
Usage: pihole-toggle <command>

Commands:
  configure  Open $CONFIG in an editor
  validate   Validate $CONFIG (no changes made)
  list       Show schedules parsed from $CONFIG
  status     Show managed timers
  apply      Write drop-ins, daemon-reload, enable --now timers
  prune      Disable/remove managed timers not present in config (removes all if SCHEDULES is empty)
  sync       Apply config and prune timers; if SCHEDULES is empty, removes all managed timers
  purge      Disable/remove all managed timers (ignores config)
EOU
}

main() {
  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    configure) cmd_configure ;;
    validate) cmd_validate ;;
    list)   cmd_list ;;
    status) cmd_status ;;
    apply)  cmd_apply ;;
    prune)  cmd_prune ;;
    sync)   cmd_sync ;;
    purge)  cmd_purge ;;
    ""|-h|--help|help) usage ;;
    *) die "Unknown command: $cmd" ;;
  esac
}

main "$@"
